// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: TypeSafeEnumeration.vsl in andromda-java-cartridge.
// Model Class: Data::AlgoTrader::com.algoTrader::enumeration::Status
// Metafacade: org.andromda.metafacades.uml.Enumeration
// Stereotype: Enumeration
//
package org.cryptocoinpartners.enumeration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/** */
public enum TargetStrategy {

  /** Aim to be x percent of the market volume */
  PERCENTAGEOFVOLUME("PERCENTAGEOFVOLUME");

  private final String enumValue;

  /** The constructor with enumeration literal value allowing super classes to access it. */
  private TargetStrategy(String value) {
    this.enumValue = value;
  }

  /**
   * Retrieves an instance of Status from <code>its name</code>.
   *
   * @param name the name to create the Status from.
   * @return The enumeration literal named after the 'name' argument
   */
  public static TargetStrategy fromString(String name) {
    return TargetStrategy.valueOf(name);
  }

  /**
   * Returns an enumeration literal String <code>value</code>. Required by JAXB2 enumeration
   * implementation
   *
   * @return String with corresponding value
   */
  public String value() {
    return this.enumValue;
  }

  /**
   * Returns an instance of Status from String <code>value</code>. Required by JAXB2 enumeration
   * implementation
   *
   * @param value the value to create the Status from.
   * @return static Enumeration with corresponding value
   */
  public static TargetStrategy fromValue(String value) {
    for (TargetStrategy enumName : TargetStrategy.values()) {
      if (enumName.getValue().equals(value)) {
        return enumName;
      }
    }
    throw new IllegalArgumentException("Status.fromValue(" + value + ')');
  }

  /**
   * Gets the underlying value of this type safe enumeration. This method is necessary to comply
   * with DaoBase implementation.
   *
   * @return The name of this literal.
   */
  public String getValue() {
    return this.enumValue;
  }

  /**
   * Returns an unmodifiable list containing the literals that are known by this enumeration.
   *
   * @return A List containing the actual literals defined by this enumeration, this list can not be
   *     modified.
   */
  public static List<String> literals() {
    return TargetStrategy.literals;
  }

  /**
   * Returns an unmodifiable list containing the names of the literals that are known by this
   * enumeration.
   *
   * @return A List containing the actual names of the literals defined by this enumeration, this
   *     list can not be modified.
   */
  public static List<String> names() {
    return TargetStrategy.names;
  }

  private static Map<String, TargetStrategy> values =
      new LinkedHashMap<String, TargetStrategy>(7, 1);
  private static List<String> literals = new ArrayList<String>(7);
  private static List<String> names = new ArrayList<String>(7);
  private static List<TargetStrategy> valueList = new ArrayList<TargetStrategy>(7);

  /** Initializes the values. */
  static {
    synchronized (TargetStrategy.values) {
      TargetStrategy.values.put(PERCENTAGEOFVOLUME.enumValue, PERCENTAGEOFVOLUME);
    }
    synchronized (TargetStrategy.valueList) {
      TargetStrategy.valueList.add(PERCENTAGEOFVOLUME);

      TargetStrategy.valueList = Collections.unmodifiableList(valueList);
    }
    synchronized (TargetStrategy.literals) {
      TargetStrategy.literals.add(PERCENTAGEOFVOLUME.enumValue);

      TargetStrategy.literals = Collections.unmodifiableList(literals);
    }
    synchronized (TargetStrategy.names) {
      TargetStrategy.names.add("PERCENTAGEOFVOLUME");
      TargetStrategy.names = Collections.unmodifiableList(names);
    }
  }
  // type-safe-enumeration-object java merge-point
}
